library("cAIC4dev")
library(gamm4)
cAIC
library(gamm4)
set.seed(0)
dat <- gamSim(1,n=400,scale=2)
dat$fac <- fac <- as.factor(sample(1:20,400,replace=TRUE))
dat$y <- dat$y + model.matrix(~fac-1)%*%rnorm(20)*.5
br <- gamm4(y~s(x3)+x1+s(x2,bs="ps"),data=dat,random=~(1|fac))
stepcAIC(br,fixEf=c("x1","x3"),trace=TRUE,direction="forward",data=dat,returnResult=FALSE)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
ttt <- stepcAIC(br,trace=TRUE,direction="backward",data=dat)
str(ttt,1)
build()
library(devtools)
build()
library("cAIC4dev")
ttt <- stepcAIC(br,trace=TRUE,direction="backward",data=dat)
str(ttt,1)
stepcAIC(br,fixEf=c("x1","x3"),trace=TRUE,direction="both",data=dat,returnResult=FALSE)
install_github("davidruegamer/cAIC4dev")
library("cAIC4dev")
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
debug(cAIC4dev)
debug(stepcAIC)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
is.list(object)
length(object) == 2
all(is.na(aicTab$caic))
build()
library("cAIC4dev")
debug(stepcAIC)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
str(aicTab,1)
load_all("R")
load_all()
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
library(parallel)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
ls.str()
debug(stepcAIC)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
cAICofMod
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
cAICofMod
install_github("davidruegamer/cAIC4dev")
library("cAIC4dev")
debug(stepcAIC)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
str(aicTab,1)
str(aicTab,1)
load_all()
debug(stepcAIC)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
str(oject,1)
str(object,1)
str(cAICofMod)
calculateAllCAICs <- function(newSetup,
# gamPos,
modelInit,
numbCores,
data,
calcNonOptimMod,
...)
{
#   if(is.null(newSetup$sPart)) isGam <- FALSE
formulaList <- lapply(newSetup,function(x)makeFormula(x,modelInit))
### create all possible models ###
listOfModels <- mclapply(formulaList, function(f)
makeUpdate(modelInit=modelInit, setup=f, data=data, ...),
mc.cores=numbCores)
#######################################################################
################### calculate alle the cAICs ##########################
#######################################################################
listOfCAICs <- tryCatch(mclapply(listOfModels,function(m){
if(any(class(m)%in%c("glm","lm"))){
ll <- getGLMll(m)
bc <- attr(stats4:::logLik(m),"df")
caic <- -2*ll + 2*bc
c(ll,bc,caic)
}else{
if(class(m)=="list"){ # m is a gamm4 object
cAIC(m,...)[c("loglikelihood","df","caic")]
}else{
if(!calcNonOptimMod){
errCode <- m@optinfo$conv$lme4$code
if(!is.null(errCode)) return(c(NA,NA,NA))
}
tryCatch(cAIC(m,...)[c("loglikelihood","df","caic")], error = function(e) return(c(NA,NA,NA)))
}
}},
mc.cores=numbCores),error=function(e)return(e))
if(is.list(listOfCAICs)) listOfCAICs <- lapply(listOfCAICs,unlist)
#######################################################################
################ list all the cAICs and models ########################
#######################################################################
aicTab <- as.data.frame(as.matrix(do.call("rbind",listOfCAICs)))
colnames(aicTab) <- c("loglikelihood","df","caic")
aicTab$models <- sapply(formulaList, makePrint, initial=FALSE)
aicTab <- as.data.frame(aicTab[,c("models","loglikelihood","df","caic")])
minInd <- which.min(aicTab$caic)
bestMod <- NA
if(length(minInd)!=0) bestMod <- listOfModels[[minInd]]
return(list(aicTab=aicTab,
bestMod=bestMod)
)
}
load_all()
debug(stepcAIC)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
library(parallel)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
y
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
cAIC(object,...)$caic
str(object,1)
library(cAIC4)
cAICofMod
debug(calculateAllCAICs)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
undebug(stepcAIC)
debug(calculateAllCAICs)
debug(cAIC4dev:::calculateAllCAICs)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
str(listOfCAICs,1)
calculateAllCAICs <- function(newSetup,
# gamPos,
modelInit,
numbCores,
data,
calcNonOptimMod,
...)
{
#   if(is.null(newSetup$sPart)) isGam <- FALSE
formulaList <- lapply(newSetup,function(x)makeFormula(x,modelInit))
### create all possible models ###
listOfModels <- mclapply(formulaList, function(f)
makeUpdate(modelInit=modelInit, setup=f, data=data, ...),
mc.cores=numbCores)
#######################################################################
################### calculate alle the cAICs ##########################
#######################################################################
listOfCAICs <- tryCatch(mclapply(listOfModels,function(m){
if(any(class(m)%in%c("glm","lm"))){
ll <- getGLMll(m)
bc <- attr(stats4:::logLik(m),"df")
caic <- -2*ll + 2*bc
c(ll,bc,caic)
}else{
if(class(m)=="list"){ # m is a gamm4 object
cAIC(m,...)[c("loglikelihood","df","caic")]
}else{
if(!calcNonOptimMod){
errCode <- m@optinfo$conv$lme4$code
if(!is.null(errCode)) return(c(NA,NA,NA))
}
tryCatch(cAIC(m,...)[c("loglikelihood","df","caic")], error = function(e) return(c(NA,NA,NA)))
}
}},
mc.cores=numbCores),error=function(e)return(e))
if(!is.null(listOfCAICs$message)) return(listOfCAICs) else listOfCAICs <- lapply(listOfCAICs,unlist)
#######################################################################
################ list all the cAICs and models ########################
#######################################################################
aicTab <- as.data.frame(as.matrix(do.call("rbind",listOfCAICs)))
colnames(aicTab) <- c("loglikelihood","df","caic")
aicTab$models <- sapply(formulaList, makePrint, initial=FALSE)
aicTab <- as.data.frame(aicTab[,c("models","loglikelihood","df","caic")])
minInd <- which.min(aicTab$caic)
bestMod <- NA
if(length(minInd)!=0) bestMod <- listOfModels[[minInd]]
return(list(aicTab=aicTab,
bestMod=bestMod)
)
}
source('~/cAIC4dev/R/step_calculateAllCAICs.R', echo=TRUE)
load_all()
library(parallel)
debug(stepcAIC)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
str(aicTab)
str(tempRes)
str(object,1)
load_all()
library(parallel)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
source('~/cAIC4dev/R/stepcAIC.R', echo=TRUE)
load_all()
library(parallel)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
tttt <- stepcAIC(br,trace=TRUE,direction="backward",data=dat)
str(tttt,1)
stepcAIC(br,fixEf=c("x1","x3"),trace=TRUE,direction="forward",data=dat,returnResult=FALSE)
install_github("davidruegamer/cAIC4dev")
library("cAIC4dev")
library(gamm4)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
build()
install_github("davidruegamer/cAIC4dev")
library("cAIC4dev")
install_github("davidruegamer/cAIC4dev")
library(devtools)
install_github("davidruegamer/cAIC4dev")
library(gamm4)
set.seed(0)
dat <- gamSim(1,n=400,scale=2)
dat$fac <- fac <- as.factor(sample(1:20,400,replace=TRUE))
dat$y <- dat$y + model.matrix(~fac-1)%*%rnorm(20)*.5
br <- gamm4(y~s(x3)+x1+s(x2,bs="ps"),data=dat,random=~(1|fac))
stepcAIC(br,fixEf=c("x1","x3"),trace=TRUE,direction="forward",data=dat,returnResult=FALSE)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
stepcAIC(br,fixEf=c("x1","x3"),trace=TRUE,direction="both",data=dat,returnResult=FALSE)
