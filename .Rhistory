mean(pvalB1s<=0.05)
mean(pvalB2s<=0.05)
mean(pvalB3s<=0.05)
str(resPval)
ggplot(melt(resPval[resPval$vars%in%6:10,c(-6,-7)],id.vars=c("ms","variable")),
aes(value)) + geom_histogram() + facet_grid(ms ~ variable)
ggplot(melt(resPval[resPval$vars%in%6:10,c(-7,-8)],id.vars=c("ms","variable")),
aes(value)) + geom_histogram() + facet_grid(ms ~ variable)
ggplot(melt(resPval[resPval$vars%in%6:10,c(-6,-7,-8)],id.vars=c("ms")),
aes(value)) + geom_histogram() + facet_grid(ms ~ variable)
ggplot(melt(resPval[resPval$vars%in%6:10,c(-6,-7,-8)],id.vars=c("ms")),
aes(value)) + geom_histogram() + facet_wrap(ms ~ variable, scales="free_y")
path = "simResults/newApproach/ms_comp_new22/"
lf <- list.files(path,pattern="sim_taylor")
resSim <- lapply(1:length(lf),function(i)readRDS(paste0(path,lf[i])))
resSim <- lapply(resSim[!sapply(resSim,is.null)],do.call,what="rbind")
resSim <- lapply(1:length(resSim),function(i){resSim[[i]]$sim<-i;return(resSim[[i]])})
resSim <- do.call("rbind",resSim)
resPval <- resSim[,c(1,4,7,10,13:16)]
#resCI <- resSim[,c(2:3,5:6,8:12)]
library(ggplot2)
library(reshape2)
# library(dplyr)
# betaDF <- data.frame(vars=1:5,betas=betas)
# resCI <- left_join(resCI,betaDF,by="vars")
## resCI$betas <- 0
## resCI[resCI$vars==1,"betas"] <- betas
resPvalAgg <- melt(aggregate(cbind(pvalNew,pvalB1,pvalB2,pvalB3)~ ms + vars,FUN=mean,data=resPval),id.vars=c("ms","vars"))
#gg_pvals <-
ggplot(resPvalAgg[resPvalAgg$vars%in%1:9,], aes(x=ms, y=value, colour=variable)) + #, group=sim)) + geom_line(alpha=0.1)
geom_line() + facet_wrap(~vars) + geom_hline(yintercept=0.05)
## gg_pvals <- ggplot(resPval, aes(x=factor(ms), y=pvalNew)) + geom_boxplot(outlier.size = 0.1) + facet_wrap(~vars)
## geom_boxplot(outlier.size = 0.1) + facet_wrap(~vars)
# gg_cis <- ggplot(melt(resCI,id.vars=c("ms","vars","sim","betas")), aes(x=factor(ms), y=value, #group=sim,
#                                                                        colour=variable)) +
#   geom_boxplot(outlier.size = 0.1) + facet_wrap(~vars, scales="free") + coord_cartesian(ylim=c(-5,5)) +
#   geom_hline(aes(yintercept=betas))
#
# saveRDS(gg_pvals,file="simResults/results/gg_pvals_per_ms_comparison_Last_IB_best.RDS")
#saveRDS(gg_cis,file="simResults/results/gg_cis_per_ms_end_nonsel_15.RDS")
#sum(resSim[resSim$vars%in%c(1:15),]$pvalNew<=0.05)/nrow(resSim[resSim$vars%in%c(1:15),])
ggplot(melt(resPval[resPval$vars%in%6:10,c(-6,-7,-8)],id.vars=c("ms")),
aes(value)) + geom_histogram() + facet_wrap(ms ~ variable, scales="free_y")
pvalNews <- resPval[!resPval$vars%in%1:5 & resPval$ms==100,"pvalNew"]
pvalB1s <- resPval[!resPval$vars%in%1:5 & resPval$ms==100,"pvalB1"]
pvalB2s <- resPval[!resPval$vars%in%1:5 & resPval$ms==100,"pvalB2"]
pvalB3s <- resPval[!resPval$vars%in%1:5 & resPval$ms==100,"pvalB3"]
length(pvalNews)
mean(pvalNews<=0.05)
mean(pvalB2s<=0.05)
mean(pvalB2s<=0.05)
mean(pvalB2s<=0.05)
pvalNews <- resPval[!resPval$vars%in%1:5 & resPval$ms==200,"pvalNew"]
pvalB1s <- resPval[!resPval$vars%in%1:5 & resPval$ms==200,"pvalB1"]
pvalB2s <- resPval[!resPval$vars%in%1:5 & resPval$ms==200,"pvalB2"]
pvalB3s <- resPval[!resPval$vars%in%1:5 & resPval$ms==200,"pvalB3"]
length(pvalNews)
mean(pvalNews<=0.05)
mean(pvalB1s<=0.05)
mean(pvalB2s<=0.05)
mean(pvalB3s<=0.05)
pvalNews <- resPval[!resPval$vars%in%1:5 & resPval$ms==300,"pvalNew"]
pvalB1s <- resPval[!resPval$vars%in%1:5 & resPval$ms==300,"pvalB1"]
pvalB2s <- resPval[!resPval$vars%in%1:5 & resPval$ms==300,"pvalB2"]
pvalB3s <- resPval[!resPval$vars%in%1:5 & resPval$ms==300,"pvalB3"]
length(pvalNews)
mean(pvalNews<=0.05)
mean(pvalB1s<=0.05)
mean(pvalB2s<=0.05)
mean(pvalB3s<=0.05)
library(devtools)
library(selectiveInference)
load_all("../iboost/")
# library(ggplot2)
# library(selectiveInference)
#source("../functions/getUpsilons.R")
#source("../functions/getCompsMboost.R")
#source("../functions/getCIbounds.R")
#source("../functions/getCompsMboost2.R")
makeBL <- function(charName,blFun,data,...) {
########### make Baselearners using character names
########### blFun specifies the type of BL
temp <- as.data.frame(data[,charName])
colnames(temp) <- charName
bl <- tryCatch(blFun(temp,...), error=function(e) bols(temp))
bl$set_names(charName)
bl
}
p <- 10
# pToConsider = 3:p
pSig = 5
nuC = 0.1
# corInVars <- matrix(c(1,0.5,0.3,0.5,1,0.5,0.3,0.5,1),ncol=3)
# A <- t(chol(corInVars))
trueSigma = 1
mstopC = 300
#alphaToConsider <- c(0.01, 0.05, 0.1, 0.2)
alpha = 0.05
set.seed(24)
betas <- 2
(betas <- c(3.5,-2.5, 1, -1, 0.5))#, -0.5, 0.2, 0.1, 4, 2))
simNr <- 4000
set.seed(43)
n = 100
X <- matrix(rnorm(n*p, 0, 1), ncol = p)
#Xcorr <- A%*%t(X[,1:pSig])
#X[,1:pSig] <- t(Xcorr)
linPred <- X[,1:pSig,drop=F]%*%betas[1:pSig]
set.seed(sss)
Y <- linPred + rnorm(n, 0, sd = trueSigma)
X <- apply(X,2,scale)
Y <- scale(Y,center=TRUE,scale=F)
X <- as.data.frame(X)
data <- data.frame(Y = Y, X = X)
blList <- lapply(colnames(X),makeBL,blFun=bols,data=X,intercept=FALSE)
mod <- mboost_fit(blg=blList, response=as.numeric(Y),
control = boost_control(mstop=mstopC,nu=nuC),
offset=0)
# summary(mod)paste0("simResults/newApproach/ms_comparison3/sim_taylor_",sss,".RDS")
X <- as.matrix(X)
#     cvr <- cvrisk(mod, fun=function(mod)return(list(risk=mod$risk()[1:mstop(mod)],
#                                                     sigEst=sapply(1:mstop(mod),function(i)
#                                                       sd(mod[i]$resid())))))
# ms <- mstop(cvrisk(mod))
# ms <- which.min(rowSums(sapply(cvr,"[[","risk")))
# ms <- mstop(mod)
# sdY <- sd(Y)
# crossCVsigma <- rowMeans(sapply(cvr,"[[","sigEst"))[ms]
#if(ms<3) return(NULL)
msSeq <- seq(100,mstopC,by=100)
mm=300
selCourse <- selected(mod[mm])
testVec <- sapply(unique(selCourse),function(z) max(which(z==selCourse)))
ss <- unique(selCourse)
betaBoosting <- sapply(coef(mod[mm]),"[[","temp")
sigma=trueSigma
nonSelected <- (1:p)[!(1:p)%in%unique(selected(mod[mm]))]
UpsOrg <- getUpsilons(mod[mm])
#     gcv <- which.min(sapply(1:length(UpsOrg), function(i) gcv.mboost(mod[mm], Ups = UpsOrg[[i]])))
#     aic <- which.min(sapply(1:length(UpsOrg), function(i) aic.mboost(mod[mm], Ups = UpsOrg[[i]])))
A <- sort(unique(selected(mod[mm])))
tV <- lapply(1:length(A),function(i)(X[,A]%*%(solve(t(X[,A])%*%X[,A])))[,i])
#     oc2 <- getVloVup(mod = mod[mm], Ups = UpsOrg, conditionOn = "last")$ul
#     oc3 <- getVloVup(mod = mod[mm], Ups = UpsOrg, conditionOn = "inBetween")$ul
#oc4 <- getLimitsFakeModel(mod = mod[mm], v = tV, nrCores = 12, sampleNr = 24, addNonSel = FALSE)
#     oc5 <- getLimitsFakeModel(mod = mod[mm], v = tV, nrCores = 5, sampleNr = 0,
#                               addNonSel = FALSE, newYdis = c(2), conditionOn = "inBetween")
#     oc6 <- getLimitsFakeModel(mod = mod[mm], v = tV, nrCores = 5, sampleNr = 0,
#                               addNonSel = TRUE, newYdis = c(2), conditionOn = "inBetween")
#     ll <- lapply(tV, function(vv) findBestPath(mod[mm], v = vv, Sigma=NULL, estSd=1,
#                    addRestByBoosting = TRUE))
ss = unique(selected(mod))
#     oc6 <- getLimitsFakeModel(mod = mod[mm], v = tV, sampleNr = 0,
#                               listOfnewSelCourses =
#                                 list(ss[order(abs(apply(X[,ss],
#                                                     2, function(x)cor(x,Y))),
#                                           decreasing = F)]),
#                               addNonSel = TRUE,
#                               conditionOn = "first")
#
btS <- backtrackSearch3(mod[mm], v=tV, nrCores = 10, Sigma = NULL, estSd=1, returnResult = TRUE)
#
#     oc6 <- lapply(btS, function(selc)
#       backtrackSearch2(mod[mm], v=tV, nrCores = 12, Sigma = NULL, estSd=1, resultIn = selc,
#                             addNonSelAtEnd = TRUE))
oc5 <- backtrackSearch3(mod[mm], v=tV, nrCores = 10, Sigma = NULL, estSd=1, resultIn = btS[[1]],
addNonSelAtEnd = FALSE)
oc6 <- backtrackSearch3(mod[mm], v=tV, nrCores = 10, Sigma = NULL, estSd=1, resultIn = btS[[1]],
addNonSelAtEnd = TRUE)
covarsMin <- max(sapply(unique(selCourse),function(z) min(which(z==selCourse))))
btS2 <- btS[[1]]
btS2 <- c(btS2,selCourse[(length(btS2)+1):covarsMin])
oc7 <- backtrackSearch3(mod[mm], v=tV, nrCores = 10, Sigma = NULL, estSd=1, resultIn = btS2,
addNonSelAtEnd = TRUE)
newComp <- calcAllCombs(mod=mod[mm], Ups=UpsOrg, estSd = 1)
cisNew <- lapply(1:length(newComp[[1]]),function(i)
try(getCIbounds(newComp$vals[[i]]$ints,
sd=sqrt(crossprod(newComp$testvec[[i]]))*sigma,
y=Y, etaT=t(newComp$testvec[[i]]), alpha = alpha)))
rle(selCourse)$values
oc2 <- getVloVup(mod = mod[mm], Ups = UpsOrg, conditionOn = "last")$ul
getVloVup
str(oc2,1)
str(oc2[[1]],1)
str(oc7,1)
combineSliceObjects <- function(obj1, obj2, what="intersection", ...)
{
stopifnot(is.list(obj1) & is.list(obj2) &
!is.null(obj1[[1]]$ints) & !is.null(obj2[[1]]$ints) &
length(obj1)==length(obj2))
resObj <- vector("list",length(obj1))
for(i in 1:length(obj1)){
resObj[[i]] <- combineIntervals(list(obj1[[i]],obj2[[i]]), what=what, ...)
}
return(resObj)
}
oc8 <- combineSliceObjects(oc7,oc2,what="union")
cisNew <- lapply(1:length(newComp[[1]]),function(i)
try(getCIbounds(newComp$vals[[i]]$ints,
sd=sqrt(crossprod(newComp$testvec[[i]]))*sigma,
y=Y, etaT=t(newComp$testvec[[i]]), alpha = alpha)))
cisNew5 <- lapply(1:length(oc5),function(i)
try(getCIbounds(oc5[[i]]$ints,
sd=sqrt(crossprod(tV[[i]]))*sigma,
y=Y, etaT=t(tV[[i]]), alpha = alpha)))
cisNew6 <- lapply(1:length(oc6),function(i)
try(getCIbounds(oc6[[i]]$ints,
sd=sqrt(crossprod(tV[[i]]))*sigma,
y=Y, etaT=t(tV[[i]]), alpha = alpha)))
cisNew7 <- lapply(1:length(oc7),function(i)
try(getCIbounds(oc7[[i]]$ints,
sd=sqrt(crossprod(tV[[i]]))*sigma,
y=Y, etaT=t(tV[[i]]), alpha = alpha)))
cisNew8 <- lapply(1:length(oc8),function(i)
try(getCIbounds(oc8[[i]]$ints,
sd=sqrt(crossprod(tV[[i]]))*sigma,
y=Y, etaT=t(tV[[i]]), alpha = alpha)))
#
oc8[[1]]
oc8[[2]]
oc8[[3]]
oc8[[4]]
oc8[[5]]
oc8[[6]]
oc8[[7]]
oc8[[8]]
oc8[[89]]
?pnorm
pnorm(1.96)
pnorm(-1.96)
oc8[[8]]$ints
oc8[[8]]$ints[[1]]
oc8[[8]]$ints[[2]]
oc8[[8]]$ints[[3]]
oc8[[8]]$ints[[4]]
a1t <- min(a1,a2)
source('~/Biosignale/Biosignale/iboost/R/getCIbounds.R', echo=TRUE)
source('~/Biosignale/Biosignale/iboost/R/getCIbounds.R', echo=TRUE)
cisNew8 <- lapply(1:length(oc8),function(i)
try(getCIbounds(oc8[[i]]$ints,
sd=sqrt(crossprod(tV[[i]]))*sigma,
y=Y, etaT=t(tV[[i]]), alpha = alpha)))
debug(twoFractionPnorm)
cisNew8 <- lapply(1:length(oc8),function(i)
try(getCIbounds(oc8[[i]]$ints,
sd=sqrt(crossprod(tV[[i]]))*sigma,
y=Y, etaT=t(tV[[i]]), alpha = alpha)))
str(a2,1)
x
b2
a2
b
b2
x
a2
x
b2
debugSource('~/Biosignale/Biosignale/iboost/R/getCIbounds.R', echo=TRUE)
source('~/Biosignale/Biosignale/iboost/R/getCIbounds.R', echo=TRUE)
library(iboost)
debugSource('~/Biosignale/Biosignale/iboost/R/getCIbounds.R', echo=TRUE)
cisNew8 <- lapply(1:length(oc8),function(i)
try(getCIbounds(oc8[[i]]$ints,
sd=sqrt(crossprod(tV[[i]]))*sigma,
y=Y, etaT=t(tV[[i]]), alpha = alpha)))
#
load_all("../iboost/")
debugSource('~/Biosignale/Biosignale/iboost/R/getCIbounds.R', echo=TRUE)
cisNew8 <- lapply(1:length(oc8),function(i)
try(getCIbounds(oc8[[i]]$ints,
sd=sqrt(crossprod(tV[[i]]))*sigma,
y=Y, etaT=t(tV[[i]]), alpha = alpha)))
#
str(a2m1)
str(a2,1)
str(b2,1)
str(x,1)
summary(x,1)
unique(x)
length(unique(x))==2 & any(is.na(x))
unique(x)[!is.na(unique(x))]
Q
source('~/Biosignale/Biosignale/iboost/R/getCIbounds.R', echo=TRUE)
load_all("../iboost/")
cisNew8 <- lapply(1:length(oc8),function(i)
try(getCIbounds(oc8[[i]]$ints,
sd=sqrt(crossprod(tV[[i]]))*sigma,
y=Y, etaT=t(tV[[i]]), alpha = alpha)))
str(cisNew8,1)
str(cisNew8[[1]],1)
str(cisNew7[[1]],1)
str(oc8,1)
str(oc8[[1]],1)
str(oc8[[2]],1)
str(oc8[[1]],2)
str(oc8[[1]])
str(oc8[[2]])
str(oc8[[3]])
str(cisNew8[[3]],1)
str(cisNew7[[3]],1)
cisNew7[[3]]$Tk
cisNew8[[3]]$Tk
str(oc8[[4]])
str(oc8[[6]])
str(oc8[[7]])
cisNew8[[7]]$Tk
cisNew7[[7]]$Tk
path = "simResults/newApproach/ms_comp_new22/"
lf <- list.files(path,pattern="sim_taylor")
resSim <- lapply(1:length(lf),function(i)readRDS(paste0(path,lf[i])))
resSim <- lapply(resSim[!sapply(resSim,is.null)],do.call,what="rbind")
resSim <- lapply(1:length(resSim),function(i){resSim[[i]]$sim<-i;return(resSim[[i]])})
resSim <- do.call("rbind",resSim)
resPval <- resSim[,c(1,4,7,10,13:16)]
#resCI <- resSim[,c(2:3,5:6,8:12)]
library(ggplot2)
library(reshape2)
# library(dplyr)
# betaDF <- data.frame(vars=1:5,betas=betas)
# resCI <- left_join(resCI,betaDF,by="vars")
## resCI$betas <- 0
## resCI[resCI$vars==1,"betas"] <- betas
resPvalAgg <- melt(aggregate(cbind(pvalNew,pvalB1,pvalB2,pvalB3)~ ms + vars,FUN=mean,data=resPval),id.vars=c("ms","vars"))
#gg_pvals <-
ggplot(resPvalAgg[resPvalAgg$vars%in%1:9,], aes(x=ms, y=value, colour=variable)) + #, group=sim)) + geom_line(alpha=0.1)
geom_line() + facet_wrap(~vars) + geom_hline(yintercept=0.05)
## gg_pvals <- ggplot(resPval, aes(x=factor(ms), y=pvalNew)) + geom_boxplot(outlier.size = 0.1) + facet_wrap(~vars)
## geom_boxplot(outli
ggplot(melt(resPval[resPval$vars%in%6:10,c(-6,-7,-8)],id.vars=c("ms")),
aes(value)) + geom_histogram() + facet_wrap(ms ~ variable, scales="free_y")
install_github("davidruegamer/cAIC4dev")
library(devtools)
install_github("davidruegamer/cAIC4dev")
library("cAIC4dev")
library(gamm4)
setwd("../../../cAIC4dev/")
library(roxygen2)
document()
check()
deocument()
document()
document()
?stepcAIC
document()
?stepcAIC
document()
?stepcAIC
document()
document()
?stepcAIC
document()
document()
document()
?stepcAIC
document()
library(cAIC4dev)
###############################################################################################################
(fm3 <- lmer(strength ~ 1 + (1|sample) + (1|batch), Pastes))
fm3_step <- stepcAIC(fm3,direction="backward", trace=TRUE, data=Pastes)
install_github("davidruegamer/cAIC4dev")
library("cAIC4dev")
(fm3 <- lmer(strength ~ 1 + (1|sample) + (1|batch), Pastes))
fm3_step <- stepcAIC(fm3,direction="backward", trace=TRUE, data=Pastes)
library(mgcv)
summary(gam(strength ~ 1 + s(sample,bs="re"),data=Pastes,method="REML"))
AIC(gam(strength ~ 1,data=Pastes,method="REML"))
AIC(gam(strength ~ 1 + s(sample,bs="re"),data=Pastes,method="REML"))
fm3_min <- lm(strength ~ 1, data=Pastes)
fm3_min_step <- stepcAIC(fm3_min,groupCandidates=c("batch","sample"),direction="forward", nestingDepth=2,
data=Pastes,trace=TRUE)
fm3_min_step <- stepcAIC(fm3_min,groupCandidates=c("batch","sample"),direction="both", data=Pastes, trace=TRUE)
fm3_min_step <- stepcAIC(fm3_min,groupCandidates=c("batch","sample"),direction="both", nestingDepth=2,
data=Pastes,trace=TRUE)
Pastes$time <- 1:dim(Pastes)[1]
fm3_slope <- lmer(data=Pastes, strength ~ 1 + (1 + time | cask))
fm3_slope_step <- stepcAIC(fm3_slope,direction="backward", trace=TRUE, data=Pastes)
fm3_min <- lm(strength ~ 1, data=Pastes)
fm3_min_step <- stepcAIC(fm3_min,groupCandidates=c("batch","sample"),direction="forward", nestingDepth=2,
data=Pastes,trace=TRUE)
fm3_inta <- lmer(strength ~ 1 + (1|sample:batch), data=Pastes)
fm3_inta_step <- stepcAIC(fm3_inta,groupCandidates=c("batch","sample"),direction="forward", nestingDepth=2,
data=Pastes,trace=TRUE)
fm3_min_step2 <- stepcAIC(fm3_min,groupCandidates=c("cask","batch","sample"),direction="forward", nestingDepth=2,
data=Pastes,trace=TRUE)
fm3_min_step3 <- stepcAIC(fm3_min,groupCandidates=c("cask","batch","sample"),direction="both", nestingDepth=2,
data=Pastes,trace=TRUE)
fm3_inta_step2 <- stepcAIC(fm3_inta,direction="backward", data=Pastes,trace=TRUE)
fm3_min_step4 <- stepcAIC(fm3_min,groupCandidates=c("cask","batch","sample"),direction="both", nestingDepth=3,
data=Pastes,trace=TRUE)
##### create own example
na <- 20
nb <- 25
n <- 400
a <- sample(1:na,400,replace=TRUE)
b <- factor(sample(1:nb,400,replace=TRUE))
x <- runif(n)
y <- 2 + 3 * x + a*.02 + rnorm(n) * .4
a <- factor(a)
c <- interaction(a,b)
y <- y + as.numeric(as.character(c))*5
df <- data.frame(y=y,x=x,a=a,b=b,c=c)
smallMod <- lm(y ~ x)
# throw error
stepcAIC(smallMod, groupCandidates=c("a","b","c"), data=df, trace=TRUE, nestingDepth=2, returnResult=FALSE)
smallMod <- lm(y ~ x, data=df)
# throw error
stepcAIC(smallMod, groupCandidates=c("a","b","c"), data=df, trace=TRUE, nestingDepth=2, returnResult=FALSE)
# get it all right
mod <- stepcAIC(smallMod, groupCandidates=c("a","b","c"),
data=df, trace=TRUE, nestingDepth=2,
direction="forward", returnResult=TRUE)
packageurl <- "https://cran.r-project.org/src/contrib/Archive/cAIC4/cAIC4_0.1.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
library(cAIC4)
cAIC4:::calculateGaussianBc()
cAIC4:::calculateGaussianBc
# make some more steps...
stepcAIC(smallMod, groupCandidates=c("a","b","c"), data=df, trace=TRUE, nestingDepth=2,
direction="both", returnResult=FALSE)
mod1 <- lmer(y ~ x + (1|a), data=df)
stepcAIC(mod1, groupCandidates=c("b","c"), data=df, trace=TRUE, nestingDepth=2, direction="forward")
stepcAIC(mod1, groupCandidates=c("b","c"), data=df, trace=TRUE, nestingDepth=2, direction="both")
mod2 <- lmer(y ~ x + (1|a) + (1|c), data=df)
stepcAIC(mod2, data=df, trace=TRUE, direction="backward")
mod3 <- lmer(y ~ x + (1|a) + (1|a:b), data=df)
stepcAIC(mod3, data=df, trace=TRUE, direction="backward")
################################################################################
# real data example
# download.file(url="http://www.stat.uni-muenchen.de/~kneib/regressionsbuch/download/buche.raw",
#                     destfile="ws.txt")
ws <- read.table("ws.txt", header=T)
summary(ws)
library(gamm4)
set.seed(0)
dat <- gamSim(1,n=400,scale=2)
dat$fac <- fac <- as.factor(sample(1:20,400,replace=TRUE))
dat$y <- dat$y + model.matrix(~fac-1)%*%rnorm(20)*.5
br <- gamm4(y~s(x3)+x1+s(x2,bs="ps"),data=dat,random=~(1|fac))
stepcAIC(br,fixEf=c("x1","x3"),trace=TRUE,direction="forward",data=dat,returnResult=FALSE)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
ttt <- stepcAIC(br,trace=TRUE,direction="backward",data=dat)
str(ttt,1)
stepcAIC(br,fixEf=c("x1","x3"),trace=TRUE,direction="both",data=dat,returnResult=FALSE)
br2 <- gamm4(y~x1,data=dat,random=~(1|fac))
stepcAIC(br2,fixEf=c("x2","x0","x1","x3"),trace=TRUE,
direction="forward",data=dat,returnResult=FALSE)
stepcAIC(br2,fixEf=c("x2","x0","x1","x3"),trace=TRUE,
direction="both",data=dat,returnResult=FALSE)
(fm3 <- lmer(strength ~ 1 + (1|sample) + (1|batch), Pastes))
fm3_step_keep <- stepcAIC(fm3,direction="backward", trace=TRUE,
data=Pastes, keep=list(random=~(1|sample)))
(fm4 <- lmer(strength ~ 1 + (1|sample) + (1|cask) + (1|batch), Pastes))
fm4_step_keep <- stepcAIC(fm4,direction="backward", trace=TRUE,
data=Pastes, keep=list(random=~(1|sample)))
(fm5 <- lmer(strength ~ 1 + (1|sample) + cask + (1|batch), Pastes))
fm5_step_keep <- stepcAIC(fm5,direction="backward", trace=TRUE,
data=Pastes, keep=list(random=~(1|sample)))
# gamm4
br <- gamm4(y~s(x0)+x1+s(x2,bs="ps"),data=dat,random=~(1|fac))
stepcAIC(br,trace=TRUE,direction="backward",
data=dat,returnResult=FALSE, keep=list(random=~(1|fac),fixed=~x1))
stepcAIC(br,trace=TRUE,direction="backward",
data=dat,returnResult=FALSE, keep=list(fixed=~x1+s(x0)))
stepcAIC(br,trace=TRUE,direction="backward",
data=dat,returnResult=FALSE, keep=list(fixed=~x1+s(x0), random=~(1|fac)))
br2 <- gamm4(y~s(x0, bs="ps")+x2,data=dat,random=~(1|fac))
stepcAIC(br2,trace=TRUE,direction="both",
fixEf=c("x1","x3"), keep=list(fixed=~s(x0,bs="ps")+x2,random=~(1|fac)),
returnResult=FALSE, data=dat)
br3 <- gamm4(y~s(x0, bs="ps")+x2,data=dat)
stepcAIC(br3,trace=TRUE,direction="both", groupCandidates="fac",
fixEf=c("x1","x3"), keep=list(fixed=~s(x0,bs="ps")+x2),
returnResult=FALSE, data=dat)
#### for paper
br <- gamm4(y~s(x3)+x1,data=dat,random=~(1|fac))
stepcAIC(br,trace=TRUE,direction="backward",data=dat)
debugSource('~/cAIC4dev/R/stepcAIC.R', echo=TRUE)
library(cAIC4dev)
debugSource('~/cAIC4dev/R/stepcAIC.R', echo=TRUE)
library("cAIC4dev")
load_all("")
load_all("R")
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
library(mclapply)
library(parallel)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
str(tempRes,1)
library("cAIC4dev")
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
str(tempRes,1)
str(tempRes$aicTab,1)
str(object,1)
minCAIC
cAICofMod
minCAIC
source('~/cAIC4dev/R/stepcAIC.R', echo=TRUE)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
ttt <- stepcAIC(br,trace=TRUE,direction="backward",data=dat)
str(ttt,1)
str(ttt,2)
library("cAIC4dev")
library(gamm4)
cAIC(br)
install.packages(cAIC4)
install.packages("cAIC4")
install.packages("cAIC4")
install.packages("cAIC4")
library(cAIC4)
cAIC(br)
library("cAIC4dev")
library(gamm4)
stepcAIC(br,trace=TRUE,direction="backward",data=dat,returnResult=FALSE)
